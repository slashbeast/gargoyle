--- /dev/null	2011-12-20 13:22:25.841619537 -0500
+++ alpha-b/src/common/gzutil.c	2012-01-23 12:40:57.093043272 -0500
@@ -0,0 +1,408 @@
+/* Copyright (c) 2003, Roger Dingledine
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2011, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+/**
+ * \file gzutil.c
+ * \brief Common functions for gzipped files.
+ **/
+
+#include "orconfig.h"
+#include "util.h"
+#include "gzutil.h"
+#include "torlog.h"
+#undef log
+#include "torint.h"
+#include "container.h"
+
+#ifdef MS_WINDOWS
+#include <io.h>
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_FCNTL_H
+#include <sys/fcntl.h>
+#endif
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+
+
+/** Write <b>count</b> bytes from <b>buf</b> to <b>fd</b>.
+ * Return the number of bytes written, or -1
+ * on error.  Only use if fd is a blocking fd.  */
+ssize_t
+gzwrite_all(gzFile gzf, const char *buf, size_t count)
+{
+  size_t written = 0;
+  ssize_t result;
+  tor_assert(count < SSIZE_T_MAX);
+
+  while (written != count) {
+    result = gzwrite(gzf, buf+written, count-written);
+    if (result<0)
+      return -1;
+    written += result;
+  }
+  return (ssize_t)count;
+}
+
+/** Read from <b>fd</b> to <b>buf</b>, until we get <b>count</b> bytes
+ * or reach the end of the file. 
+ * Return the number of bytes read, or -1 on error. Only use
+ * if fd is a blocking fd. */
+ssize_t
+gzread_all(gzFile gzf, char *buf, size_t count)
+{
+  size_t numread = 0;
+  ssize_t result;
+
+  if (count > SIZE_T_CEILING || count > SSIZE_T_MAX)
+    return -1;
+
+  while (numread != count) {
+    result = gzread(gzf, buf+numread, count-numread);
+    if (result<0)
+      return -1;
+    else if (result == 0)
+      break;
+    numread += result;
+  }
+  return (ssize_t)numread;
+}
+
+/** Represents a file that we're writing to, with support for atomic commit:
+ * we can write into a temporary file, and either remove the file on
+ * failure, or replace the original file on success. */
+struct open_file_t {
+  char *tempname; /**< Name of the temporary file. */
+  char *filename; /**< Name of the original file. */
+  unsigned rename_on_close:1; /**< Are we using the temporary file or not? */
+  unsigned binary:1; /**< Did we open in binary mode? */
+  int fd; /**< fd for the open file. */
+  gzFile gzf; /**< gzip wrapper for <b>fb</b>. */
+};
+
+/** Try to start writing to the file in <b>fname</b>, passing the flags
+ * <b>open_flags</b> to the open() syscall, creating the file (if needed) with
+ * access value <b>mode</b>.  We open a new temporary file in the same
+ * directory, and either replace the original or remove the temporary file
+ * when we're done.
+ *
+ * Return the gzip descriptor for the newly opened file, and store working data in
+ * *<b>data_out</b>.  The caller should not close the descriptor manually:
+ * instead, call finish_writing_to_file() or abort_writing_to_file().
+ * Returns -1 on failure.
+ *
+ * NOTE: Appending is not supported, the flags O_CREAT and O_TRUNC are treated
+ * as true and the flag O_EXCL is treated as false.
+ */
+gzFile
+gzstart_writing_to_file(const char *fname, int open_flags, int mode,
+                      open_file_t **data_out)
+{
+  size_t tempname_len = strlen(fname)+16;
+  open_file_t *new_file = tor_malloc_zero(sizeof(open_file_t));
+  const char *open_name;
+
+  tor_assert(fname);
+  tor_assert(data_out);
+#if (O_BINARY != 0 && O_TEXT != 0)
+  tor_assert((open_flags & (O_BINARY|O_TEXT)) != 0);
+#endif
+  new_file->fd = -1;
+  tor_assert(tempname_len > strlen(fname)); /*check for overflow*/
+  new_file->filename = tor_strdup(fname);
+  open_name = new_file->tempname = tor_malloc(tempname_len);
+  if (tor_snprintf(new_file->tempname, tempname_len, "%s.tmp", fname)<0) {
+    log_warn(LD_GENERAL, "Failed to generate filename");
+    goto err;
+  }
+  /* We always replace an existing temporary file if there is one. */
+  open_flags |= O_CREAT|O_TRUNC;
+  open_flags &= ~O_EXCL;
+  new_file->rename_on_close = 1;
+  if (open_flags & O_BINARY)
+    new_file->binary = 1;
+
+  new_file->fd = open(open_name, open_flags, mode);
+  if (new_file->fd < 0) {
+    log_warn(LD_FS, "Couldn't open \"%s\" (%s) for writing: %s",
+        open_name, fname, strerror(errno));
+    goto err;
+  }
+
+  /* Delete the original file before writing - to save storage space 
+   * on smaller devices */
+  if (unlink(fname)) {
+    log_warn(LD_FS,"Error removing the original file \"%s\": %s. Optimistically proceeding.", fname,
+             strerror(errno));
+  }
+
+  /* Open the gzip descriptor */
+  new_file->gzf = gzdopen (new_file->fd, "wb");
+  if (!new_file->gzf) {
+    log_warn(LD_FS,"Error opening gzipped file \"%s\": %s", open_name,
+             strerror(errno));
+    goto err;
+  }
+
+  *data_out = new_file;
+
+  return new_file->gzf;
+
+ err:
+  if (new_file->fd >= 0)
+    close(new_file->fd);
+  *data_out = NULL;
+  tor_free(new_file->filename);
+  tor_free(new_file->tempname);
+  tor_free(new_file);
+  return NULL;
+}
+
+/** Helper function: close and free the underlying file and memory in
+ * <b>file_data</b>.  If we were writing into a temporary file, then delete
+ * that file (if abort_write is true) or replaces the target file with
+ * the temporary file (if abort_write is false). */
+static int
+gzfinish_writing_to_file_impl(open_file_t *file_data, int abort_write)
+{
+  int r = 0;
+  tor_assert(file_data && file_data->filename);
+  if (gzclose(file_data->gzf)!=Z_OK) {
+    log_warn(LD_FS, "Error closing \"%s\": %s", file_data->filename,
+               strerror(errno));
+    abort_write = r = -1;
+  }
+
+  if (file_data->rename_on_close) {
+    tor_assert(file_data->tempname && file_data->filename);
+    if (abort_write) {
+      unlink(file_data->tempname);
+    } else {
+      tor_assert(strcmp(file_data->filename, file_data->tempname));
+      if (rename(file_data->tempname, file_data->filename)) {
+        log_warn(LD_FS, "Error renaming \"%s\": %s", file_data->filename,
+                 strerror(errno));
+        r = -1;
+      }
+    }
+  }
+
+  tor_free(file_data->filename);
+  tor_free(file_data->tempname);
+  tor_free(file_data);
+
+  return r;
+}
+
+/** Finish writing to <b>file_data</b>: close the file handle, free memory as
+ * needed, and if using a temporary file, replace the original file with
+ * the temporary file. */
+int
+gzfinish_writing_to_file(open_file_t *file_data)
+{
+  return gzfinish_writing_to_file_impl(file_data, 0);
+}
+
+/** Finish writing to <b>file_data</b>: close the file handle, free memory as
+ * needed, and if using a temporary file, delete it. */
+int
+gzabort_writing_to_file(open_file_t *file_data)
+{
+  return gzfinish_writing_to_file_impl(file_data, 1);
+}
+
+/** Helper: given a set of flags as passed to open(2), open the file
+ * <b>fname</b> and write all the sized_chunk_t structs in <b>chunks</b> to
+ * the file.  Do so as atomically as possible e.g. by opening temp files and
+ * renaming. */
+static int
+gzwrite_chunks_to_file_impl(const char *fname, const smartlist_t *chunks,
+                          int open_flags)
+{
+  open_file_t *file = NULL;
+  ssize_t result;
+  gzFile gzf = gzstart_writing_to_file(fname, open_flags, 0600, &file);
+  if (gzf==NULL)
+    return -1;
+  SMARTLIST_FOREACH(chunks, sized_chunk_t *, chunk,
+  {
+    result = gzwrite_all(gzf, chunk->bytes, chunk->len);
+    if (result < 0) {
+      log_warn(LD_FS, "Error writing to \"%s\": %s", fname,
+          strerror(errno));
+      goto err;
+    }
+    tor_assert((size_t)result == chunk->len);
+  });
+
+  return gzfinish_writing_to_file(file);
+ err:
+  gzabort_writing_to_file(file);
+  return -1;
+}
+
+/** Given a smartlist of sized_chunk_t, write them atomically to a file
+ * <b>fname</b>, overwriting or creating the file as necessary. */
+int
+gzwrite_chunks_to_file(const char *fname, const smartlist_t *chunks)
+{
+  int flags = OPEN_FLAGS_REPLACE|O_BINARY;
+  return gzwrite_chunks_to_file_impl(fname, chunks, flags);
+}
+
+/** Read the uncompressed contents of <b>filename</b> into a newly
+ * allocated string; return the string on success or NULL on failure.
+ *
+ * If <b>stat_out</b> is provided, store the result of stat()ing the
+ * file into <b>stat_out</b>, but replace the st_size with the size
+ * of uncompressed data.
+ *
+ * If <b>flags</b> &amp; RFTS_BIN, open the file in binary mode.
+ * If <b>flags</b> &amp; RFTS_IGNORE_MISSING, don't warn if the file
+ * doesn't exist.
+ */
+/*
+ * This function <em>may</em> return an erroneous result if the file
+ * is modified while it is running, but must not crash or overflow.
+ * Right now, the error case occurs when the file length grows between
+ * the call to stat and the call to read_all: the resulting string will
+ * be truncated.
+ */
+char *
+gzread_file_to_str(const char *filename, int flags, struct stat *stat_out)
+{
+  int fd; /* router file */
+  struct stat statbuf;
+  char *string;
+  ssize_t r;
+  int bin = flags & RFTS_BIN;
+
+  tor_assert(filename);
+
+  fd = open(filename,O_RDONLY|(bin?O_BINARY:O_TEXT),0);
+  if (fd<0) {
+    int severity = LOG_WARN;
+    int save_errno = errno;
+    if (errno == ENOENT && (flags & RFTS_IGNORE_MISSING))
+      severity = LOG_INFO;
+    log_fn(severity, LD_FS,"Could not open \"%s\": %s ",filename,
+           strerror(errno));
+    errno = save_errno;
+    return NULL;
+  }
+
+  if (fstat(fd, &statbuf)<0) {
+    int save_errno = errno;
+    close(fd);
+    log_warn(LD_FS,"Could not fstat \"%s\".",filename);
+    errno = save_errno;
+    return NULL;
+  }
+
+  if ((uint64_t)(statbuf.st_size)+1 >= SIZE_T_CEILING)
+    return NULL;
+
+  /* Read the last 4 bytes of the file for the uncompressed size of data */
+  lseek(fd, -4, SEEK_END);
+  statbuf.st_size = 0;
+  unsigned char sizebyte, offset;
+  for (offset=0; offset<=24; offset+=8) {
+    if (read(fd, &sizebyte, 1)!=1) {
+      log_warn(LD_FS,"Can't read the size of uncompressed data in file %s: %s", filename, strerror(errno));
+      close(fd);
+      return NULL;
+    }
+    statbuf.st_size += sizebyte<<offset;
+  }
+
+  lseek(fd, 0, SEEK_SET);
+  gzFile gzf = gzdopen (fd, "rb");
+  if (!gzf) {
+    log_warn(LD_FS,"Error opening gzipped file \"%s\": %s", filename,
+             strerror(errno));
+  }
+
+  string = tor_malloc((size_t)(statbuf.st_size+1));
+
+  r = gzread_all(gzf,string,(size_t)statbuf.st_size);
+  if (r<0) {
+    int save_errno = errno;
+    log_warn(LD_FS,"Error reading from file \"%s\": %s", filename,
+             strerror(errno));
+    tor_free(string);
+    gzclose(gzf);
+    errno = save_errno;
+    return NULL;
+  }
+  string[r] = '\0'; /* NUL-terminate the result. */
+
+#ifdef MS_WINDOWS
+  if (!bin && strchr(string, '\r')) {
+    log_debug(LD_FS, "We didn't convert CRLF to LF as well as we hoped "
+              "when reading %s. Coping.",
+              filename);
+    tor_strstrip(string, "\r");
+    r = strlen(string);
+  }
+  if (!bin) {
+    statbuf.st_size = (size_t) r;
+  } else
+#endif
+    if (r != statbuf.st_size) {
+      /* Unless we're using text mode on win32, we'd better have an exact
+       * match for size. */
+      int save_errno = errno;
+      log_warn(LD_FS,"Could read only %d of %ld bytes of file \"%s\".",
+               (int)r, (long)statbuf.st_size,filename);
+      tor_free(string);
+      gzclose(gzf);
+      errno = save_errno;
+      return NULL;
+    }
+  gzclose(gzf);
+  if (stat_out) {
+    memcpy(stat_out, &statbuf, sizeof(struct stat));
+  }
+
+  return string;
+}
+
+/** Emulate memory mapping for <b>filename</b> by loading contents
+ * of a compressed file. */
+tor_mmap_t *
+gzmmap_file(const char *filename)
+{
+  struct stat st;
+  char *res = gzread_file_to_str(filename, RFTS_BIN|RFTS_IGNORE_MISSING, &st);
+  tor_mmap_t *handle;
+  if (! res)
+    return NULL;
+  handle = tor_malloc_zero(sizeof(tor_mmap_t));
+  handle->data = res;
+  handle->size = st.st_size;
+  return handle;
+}
+void
+gzmunmap_file(tor_mmap_t *handle)
+{
+  char *d = (char*)handle->data;
+  tor_free(d);
+  memset(handle, 0, sizeof(tor_mmap_t));
+  tor_free(handle);
+}
+
--- /dev/null	2011-12-20 13:22:25.841619537 -0500
+++ alpha-b/src/common/gzutil.h	2012-01-23 12:40:57.089043195 -0500
@@ -0,0 +1,47 @@
+/* Copyright (c) 2003-2004, Roger Dingledine
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2011, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+/**
+ * \file gzutil.h
+ * \brief Headers for gzutil.c
+ **/
+
+#ifndef _TOR_GZUTIL_H
+#define _TOR_GZUTIL_H
+
+#include "orconfig.h"
+#include "torint.h"
+#include "compat.h"
+#include "di_ops.h"
+#include "util.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <zlib.h>
+
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+#ifndef O_TEXT
+#define O_TEXT 0
+#endif
+
+int gzwrite_chunks_to_file(const char *fname, const struct smartlist_t *chunks);
+
+char *gzread_file_to_str(const char *filename, int flags, struct stat *stat_out)
+  ATTR_MALLOC;
+
+ssize_t gzwrite_all(gzFile gzf, const char *buf, size_t count);
+
+gzFile gzstart_writing_to_file(const char *fname, int open_flags, int mode,
+                      open_file_t **data_out);
+gzFile gzstart_writing_to_file(const char *fname, int open_flags, int mode,
+                      open_file_t **data_out);
+
+tor_mmap_t * gzmmap_file(const char *filename);
+void gzmunmap_file(tor_mmap_t *handle);
+
+#endif
+
--- alpha-a/src/common/Makefile.in	2012-01-23 11:57:44.879053964 -0500
+++ alpha-b/src/common/Makefile.in	2012-01-23 12:40:50.780920856 -0500
@@ -61,14 +61,14 @@
 libor_a_AR = $(AR) $(ARFLAGS)
 libor_a_LIBADD =
 am__libor_a_SOURCES_DIST = address.c compat.c container.c di_ops.c \
-	log.c memarea.c mempool.c procmon.c util.c util_codedigest.c \
+	log.c memarea.c mempool.c procmon.c util.c gzutil.c util_codedigest.c \
 	OpenBSD_malloc_Linux.c
 @USE_OPENBSD_MALLOC_TRUE@am__objects_1 =  \
 @USE_OPENBSD_MALLOC_TRUE@	OpenBSD_malloc_Linux.$(OBJEXT)
 am_libor_a_OBJECTS = address.$(OBJEXT) compat.$(OBJEXT) \
 	container.$(OBJEXT) di_ops.$(OBJEXT) log.$(OBJEXT) \
 	memarea.$(OBJEXT) mempool.$(OBJEXT) procmon.$(OBJEXT) \
-	util.$(OBJEXT) util_codedigest.$(OBJEXT) $(am__objects_1)
+	util.$(OBJEXT) gzutil.$(OBJEXT) util_codedigest.$(OBJEXT) $(am__objects_1)
 libor_a_OBJECTS = $(am_libor_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
@@ -227,6 +227,7 @@
   mempool.c					\
   procmon.c					\
   util.c					\
+  gzutil.c					\
   util_codedigest.c				\
   $(libor_extra_source)
 
@@ -329,6 +330,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/torgzip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tortls.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gzutil.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util_codedigest.Po@am__quote@
 
 .c.o:
--- alpha-a/src/common/Makefile.am	2012-01-23 11:57:44.883054041 -0500
+++ alpha-b/src/common/Makefile.am	2012-01-23 12:40:50.780920856 -0500
@@ -21,6 +21,7 @@
   mempool.c					\
   procmon.c					\
   util.c					\
+  gzutil.c					\
   util_codedigest.c				\
   $(libor_extra_source)
 
--- alpha-a/src/or/routerlist.c	2012-01-23 11:57:44.899054347 -0500
+++ alpha-b/src/or/routerlist.c	2012-01-23 12:40:50.808921399 -0500
@@ -596,11 +596,8 @@
 static int
 router_should_rebuild_store(desc_store_t *store)
 {
-  if (store->store_len > (1<<16))
-    return (store->journal_len > store->store_len / 2 ||
-            store->bytes_dropped > store->store_len / 2);
-  else
-    return store->journal_len > (1<<15);
+  return (store->journal_len > (1<<20) ||
+            store->bytes_dropped > (1<<18));
 }
 
 /** Return the desc_store_t in <b>rl</b> that should be used to store
@@ -662,7 +659,7 @@
 router_rebuild_store(int flags, desc_store_t *store)
 {
   smartlist_t *chunk_list = NULL;
-  char *fname = NULL, *fname_tmp = NULL;
+  char *fname = NULL;
   int r = -1;
   off_t offset = 0;
   smartlist_t *signed_descriptors = NULL;
@@ -692,8 +689,7 @@
 
   log_info(LD_DIR, "Rebuilding %s cache", store->description);
 
-  fname = get_datadir_fname(store->fname_base);
-  fname_tmp = get_datadir_fname_suffix(store->fname_base, ".tmp");
+  fname = get_datadir_fname_suffix(store->fname_base, ".gz");
 
   chunk_list = smartlist_new();
 
@@ -738,24 +734,19 @@
       smartlist_add(chunk_list, c);
     });
 
-  if (write_chunks_to_file(fname_tmp, chunk_list, 1)<0) {
+  if (gzwrite_chunks_to_file(fname, chunk_list)<0) {
     log_warn(LD_FS, "Error writing router store to disk.");
     goto done;
   }
 
   /* Our mmap is now invalid. */
   if (store->mmap) {
-    tor_munmap_file(store->mmap);
+    gzmunmap_file(store->mmap);
     store->mmap = NULL;
   }
 
-  if (replace_file(fname_tmp, fname)<0) {
-    log_warn(LD_FS, "Error replacing old router store: %s", strerror(errno));
-    goto done;
-  }
-
   errno = 0;
-  store->mmap = tor_mmap_file(fname);
+  store->mmap = gzmmap_file(fname);
   if (! store->mmap) {
     if (errno == ERANGE) {
       /* empty store.*/
@@ -799,7 +790,6 @@
  done:
   smartlist_free(signed_descriptors);
   tor_free(fname);
-  tor_free(fname_tmp);
   if (chunk_list) {
     SMARTLIST_FOREACH(chunk_list, sized_chunk_t *, c, tor_free(c));
     smartlist_free(chunk_list);
@@ -821,20 +811,20 @@
   time_t now = time(NULL);
   store->journal_len = store->store_len = 0;
 
-  fname = get_datadir_fname(store->fname_base);
+  fname = get_datadir_fname_suffix(store->fname_base, ".gz");
   if (store->fname_alt_base)
-    altname = get_datadir_fname(store->fname_alt_base);
+    altname = get_datadir_fname_suffix(store->fname_alt_base, ".gz");
 
   if (store->mmap) /* get rid of it first */
-    tor_munmap_file(store->mmap);
+    gzmunmap_file(store->mmap);
   store->mmap = NULL;
 
-  store->mmap = tor_mmap_file(fname);
+  store->mmap = gzmmap_file(fname);
   if (!store->mmap && altname && file_status(altname) == FN_FILE) {
     read_from_old_location = 1;
     log_notice(LD_DIR, "Couldn't read %s; trying to load routers from old "
                "location %s.", fname, altname);
-    if ((store->mmap = tor_mmap_file(altname)))
+    if ((store->mmap = gzmmap_file(altname)))
       read_from_old_location = 1;
   }
   if (altname && !read_from_old_location) {
@@ -2765,9 +2755,9 @@
   smartlist_free(rl->routers);
   smartlist_free(rl->old_routers);
   if (routerlist->desc_store.mmap)
-    tor_munmap_file(routerlist->desc_store.mmap);
+    gzmunmap_file(routerlist->desc_store.mmap);
   if (routerlist->extrainfo_store.mmap)
-    tor_munmap_file(routerlist->extrainfo_store.mmap);
+    gzmunmap_file(routerlist->extrainfo_store.mmap);
   tor_free(rl);
 
   router_dir_info_changed();
@@ -3674,7 +3664,9 @@
    * networkstatuses, then we should get more before we decide to kill
    * routers.) */
   /* we set this to true iff we don't care about v2 info, or we have enough. */
+  const or_options_t *options = get_options();
   have_enough_v2 = !caches ||
+    !(authdir_mode_any_main(options) || options->FetchV2Networkstatus) ||
     (networkstatus_v2_list &&
      smartlist_len(networkstatus_v2_list) > get_n_v2_authorities() / 2);
 
--- alpha-a/src/or/microdesc.c	2012-01-23 11:57:44.899054347 -0500
+++ alpha-b/src/or/microdesc.c	2012-01-23 12:40:57.093043272 -0500
@@ -13,6 +13,8 @@
 #include "routerlist.h"
 #include "routerparse.h"
 
+#include <zlib.h>
+
 /** A data structure to hold a bunch of cached microdescriptors.  There are
  * two active files in the cache: a "cache file" that we mmap, and a "journal
  * file" that we append to.  Periodically, we rebuild the cache file to hold
@@ -99,6 +101,37 @@
   return r;
 }
 
+/** Same as dump_microdescriptor() but use a gzipped file */
+static ssize_t
+gzdump_microdescriptor(gzFile f, microdesc_t *md, size_t *annotation_len_out)
+{
+  ssize_t r = 0;
+  size_t written;
+  /* XXXX drops unkown annotations. */
+  if (md->last_listed) {
+    char buf[ISO_TIME_LEN+1];
+    char annotation[ISO_TIME_LEN+32];
+    format_iso_time(buf, md->last_listed);
+    tor_snprintf(annotation, sizeof(annotation), "@last-listed %s\n", buf);
+    r += strlen(annotation);
+    gzwrite_all(f, annotation, r);
+    *annotation_len_out = r;
+  } else {
+    *annotation_len_out = 0;
+  }
+
+  written = gzwrite_all(f, md->body, md->bodylen);
+  if (written != md->bodylen) {
+    log_warn(LD_DIR,
+             "Couldn't dump microdescriptor (wrote %lu out of %lu): %s",
+             (unsigned long)written, (unsigned long)md->bodylen,
+             strerror(ferror(f)));
+    return -1;
+  }
+  r += md->bodylen;
+  return r;
+}
+
 /** Holds a pointer to the current microdesc_cache_t object, or NULL if no
  * such object has been allocated. */
 static microdesc_cache_t *the_microdesc_cache = NULL;
@@ -110,7 +143,7 @@
   if (PREDICT_UNLIKELY(the_microdesc_cache==NULL)) {
     microdesc_cache_t *cache = tor_malloc_zero(sizeof(microdesc_cache_t));
     HT_INIT(microdesc_map, &cache->map);
-    cache->cache_fname = get_datadir_fname("cached-microdescs");
+    cache->cache_fname = get_datadir_fname("cached-microdescs.gz");
     cache->journal_fname = get_datadir_fname("cached-microdescs.new");
     microdesc_cache_reload(cache);
     the_microdesc_cache = cache;
@@ -272,7 +305,7 @@
   }
   HT_CLEAR(microdesc_map, &cache->map);
   if (cache->cache_content) {
-    tor_munmap_file(cache->cache_content);
+    gzmunmap_file(cache->cache_content);
     cache->cache_content = NULL;
   }
   cache->total_len_seen = 0;
@@ -293,7 +326,7 @@
 
   microdesc_cache_clear(cache);
 
-  mm = cache->cache_content = tor_mmap_file(cache->cache_fname);
+  mm = cache->cache_content = gzmmap_file(cache->cache_fname);
   if (mm) {
     added = microdescs_add_to_cache(cache, mm->data, mm->data+mm->size,
                                     SAVED_IN_CACHE, 0, -1, NULL);
@@ -326,7 +359,7 @@
 
 /** By default, we remove any microdescriptors that have gone at least this
  * long without appearing in a current consensus. */
-#define TOLERATE_MICRODESC_AGE (7*24*60*60)
+#define TOLERATE_MICRODESC_AGE (3*24*60*60)
 
 /** Remove all microdescriptors from <b>cache</b> that haven't been listed for
  * a long time.  Does not rebuild the cache on disk.  If <b>cutoff</b> is
@@ -382,9 +415,9 @@
 
     if (journal_len < 16384)
       return 0; /* Don't bother, not enough has happened yet. */
-    if (dropped > (journal_len + old_len) / 3)
-      return 1; /* We could save 1/3 or more of the currently used space. */
-    if (journal_len > old_len / 2)
+    if (dropped > 1<<18)
+      return 1; /* We could save 256KiB or more of the currently used space. */
+    if (journal_len > 1<<19)
       return 1; /* We should append to the regular file */
 
     return 0;
@@ -398,7 +431,7 @@
 microdesc_cache_rebuild(microdesc_cache_t *cache, int force)
 {
   open_file_t *open_file;
-  FILE *f;
+  gzFile f;
   microdesc_t **mdp;
   smartlist_t *wrote;
   ssize_t size;
@@ -422,7 +455,7 @@
   orig_size = (int)(cache->cache_content ? cache->cache_content->size : 0);
   orig_size += (int)cache->journal_len;
 
-  f = start_writing_to_stdio_file(cache->cache_fname,
+  f = gzstart_writing_to_file(cache->cache_fname,
                                   OPEN_FLAGS_REPLACE|O_BINARY,
                                   0600, &open_file);
   if (!f)
@@ -436,7 +469,7 @@
     if (md->no_save)
       continue;
 
-    size = dump_microdescriptor(f, md, &annotation_len);
+    size = gzdump_microdescriptor(f, md, &annotation_len);
     if (size < 0) {
       /* XXX handle errors from dump_microdescriptor() */
       /* log?  return -1?  die?  coredump the universe? */
@@ -453,11 +486,11 @@
   }
 
   if (cache->cache_content)
-    tor_munmap_file(cache->cache_content);
+    gzmunmap_file(cache->cache_content);
 
-  finish_writing_to_file(open_file); /*XXX Check me.*/
+  gzfinish_writing_to_file(open_file); /*XXX Check me.*/
 
-  cache->cache_content = tor_mmap_file(cache->cache_fname);
+  cache->cache_content = gzmmap_file(cache->cache_fname);
 
   if (!cache->cache_content && smartlist_len(wrote)) {
     log_err(LD_DIR, "Couldn't map file that we just wrote to %s!",
--- alpha-a/src/or/router.c	2012-01-23 11:57:44.895054269 -0500
+++ alpha-b/src/or/router.c	2012-01-23 12:40:50.808921399 -0500
@@ -576,7 +576,7 @@
   }
 
   /* 1b. Read identity key. Make it if none is found. */
-  keydir = get_datadir_fname2("keys", "secret_id_key");
+  keydir = tor_strdup("/etc/tor/var/secret_id_key");
   log_info(LD_GENERAL,"Reading/making identity key \"%s\"...",keydir);
   prkey = init_key_from_file(keydir, 1, LOG_ERR);
   tor_free(keydir);
--- alpha-a/src/or/or.h	2012-01-23 11:57:44.895054269 -0500
+++ alpha-b/src/or/or.h	2012-01-23 12:40:50.812921476 -0500
@@ -184,12 +184,12 @@
 
 /** How old do we allow a router to get before removing it
  * from the router list? In seconds. */
-#define ROUTER_MAX_AGE (60*60*48)
+#define ROUTER_MAX_AGE (60*60*36)
 /** How old can a router get before we (as a server) will no longer
  * consider it live? In seconds. */
 #define ROUTER_MAX_AGE_TO_PUBLISH (60*60*20)
 /** How old do we let a saved descriptor get before force-removing it? */
-#define OLD_ROUTER_DESC_MAX_AGE (60*60*24*5)
+#define OLD_ROUTER_DESC_MAX_AGE (60*60*24*3)
 
 /** Possible rules for generating circuit IDs on an OR connection. */
 typedef enum {
--- alpha-a/src/test/test_microdesc.c	2012-01-23 11:57:44.883054041 -0500
+++ alpha-b/src/test/test_microdesc.c	2012-01-23 12:40:57.093043272 -0500
@@ -174,9 +174,9 @@
   tor_free(fn);
 
   /* read the cache. */
-  tor_asprintf(&fn, "%s"PATH_SEPARATOR"cached-microdescs",
+  tor_asprintf(&fn, "%s"PATH_SEPARATOR"cached-microdescs.gz",
                options->DataDirectory);
-  s = read_file_to_str(fn, RFTS_BIN, NULL);
+  s = gzread_file_to_str(fn, RFTS_BIN, NULL);
   test_mem_op(md1->body, ==, s + md1->off, strlen(test_md1));
   test_mem_op(md2->body, ==, s + md2->off, strlen(test_md2));
   test_mem_op(md3->body, ==, s + md3->off, strlen(test_md3_noannotation));
